# Vývojářský deník
### 1. den
Hned na samotném začátku na mě čekal velice obtížný úkol. Navrhnout jakým způsobem bude kostka reprezentována v paměti. Dlouho jsem nad tím přemýšlel až jsem nakonec dospěl k tomuto řešení. V rámci třídy Side budu ukládat jednotlivé kostky (4 rohové, 4 boční a 1 středovou) každé z šesti stěn. Každá z těchto kostek bude ukládat informace o všech svých barvách. Tedy i o barvách které se nacházejí na okolních stěnách. Slibuji si od toho pohodlnější implementaci algoritmů pro řešení kostky. Jednotlivé stěny jsou pak uloženy v rámci pole ve třídě Cube. Zde si také pamatuji jakým způsobem je kostka natočena k řešiteli (pozorovateli) a to tak, že si ukládám jaká je středová barva horní a čelní stěny.

Při psaní jsem však narazil na drobný problém. Původně jsem chtěl jednotlivé kostky uložit do jednoho pole. To by se dalo udělat přes společný interface. Jenže kostky nemají jednotný počet barev a proto by bylo složité vracet jejich hodnoty pomocí metod z jednoho předka. Interface jsem prozatím v kódu ponechal, možná se k jeho plné implementaci v budoucnu vratím. Nyní jsem však tuto myšlenku opustil a strana si ukládá kostky v rámci specializovaných polí. Zároveň trochu začínám pochybovat jestli zvolené řešení není zbytečně komplikované. Nic mi ale nebrání se v budoucnu uchýlit k jednodušší variantě. Například si v rámci stěn nadefinovat pouze pole barev, kde bych si pamatoval pouze barvy dané stěny.

Přesto, že ve výsledku půjde o WinForm aplikaci uchýlil jsem se zatím pouze ke konzolovému výstupu. Bylo jednodušší ho implementovat a lze s ním lehce otestovat funkčnost kódu. Jedinou nevýhodou je absence oranžové barvy v konzoli. Oranžová je tedy nahrazena magentou. 

Momentálně umí program uložit do paměti vyřešenou kostku a zpětně ji vypsat do konzole. V následujících dnech mě čeká implementace funkcí pro pohyb kostky. S jejich pomocí pak půjde s kostkou v paměti otáčet. Následovat bude postupná implementace jednotlivých algoritmů.

### 2. den
Dnes jsem se pustil do implementace pohybů kostky. Začal jsem těmi základními, tedy U, D, R, L, F, B a jejich inverzemi. Chvíli mi přišlo, že to bude lehce problematické, protože kostka se v době, kdy má k pohybu dojít, nemusí nacházet v počáteční pozici (tu jsem si definoval tak, že čelní stěna kostky je červená a horní žlutá). Záhy jsem ale přišel na to, že to až tak velký problém nebude. Postačí všechny pohyby naprogramovat pro tuto základní polohu a případné otáčení v jiných polohách nahradit korespondujícími pohyby v základní poloze.

Vrhnul jsem se tedy na implementaci. Během ní jsem se opět dostal k problému jak jednotlivé strany reprezentovat v paměti. Myslel jsem, že se mi moje obsáhlejší reprezentace bude hodit při implementaci. Ukázalo se však, že není vůbec potřeba. Rozhodl jsem se tedy reprezentaci zjednodušit. Jednotlivé stěny si tak ukládají pouze pole stejných políček, kde v každém je uložena pouze barva na dané stěně. Zatím ale nechci uplně vyhodit ani starou složitější reprezentaci. V kódu jsem ji tak zatím ponechal v rámci komentářů a pokud se v budoucnu ukáže, že by se mi hodila tak se k ní vrátím.

Po naimplementování všech základních pohybů jsem se zamyslel nad implementací těch složitějších. Došlo mi, že je možné je naimplementovat pomocí těch základních a rotace. Začal jsem tedy s implementací rotace. Po dokončení jsem si chtěl funkčnost otestovat. Narazil jsem však na menší problém. Došlo mi, že tak jak mám základní pohyby L, R, F a B naimplementované tak jsou dobré pouze pokud je kostka v počáteční pozici. Jinak totiž nesedí rozložení políček na bílé a žluté stěně. Při hledání řešení jsem si uvědomil další nedostatek mého kódu. Ukázalo se totiž, že pohyby F a B by bylo možné naimplementovat i pomocí L a R. A pokud by se to mělo vzít do detailu pohyb L, lze nahradit pohybem R (a obráceně samozřejmě). Bylo by potřeba pouze vhodně zadat parametry pro pohyb.

Zároveň jsem si uvědolmil, že ani moje jednoduchá funkce na vypsaní kostky není bez chyb. Dokáže totiž kostku vypsat pouze v základní pozici a to i když je v paměti uložena v jiné. V budoucnu ji tedy budu muset upravit tak, aby dokázala kostku vypsat v takové pozici jaká je právě uložena v paměti.

Dnes tedy končím s rozpracovanou implementací pohybu. Díky chybám v základních pohybech jsem se k pokročilým nedostal. Během dalších dnů doladím pohyb kosty. Nejspíš se pokusím pohyby co nejvíce ořezat. Počítám, že mi nakonec zbyde pouze implementace pohybů U, D, R a jejich inverzí.
