# Vývojářský deník
### 1. den
Hned na samotném začátku na mě čekal velice obtížný úkol. Navrhnout jakým způsobem bude kostka reprezentována v paměti. Dlouho jsem nad tím přemýšlel až jsem nakonec dospěl k tomuto řešení. V rámci třídy Side budu ukládat jednotlivé kostky (4 rohové, 4 boční a 1 středovou) každé z šesti stěn. Každá z těchto kostek bude ukládat informace o všech svých barvách. Tedy i o barvách které se nacházejí na okolních stěnách. Slibuji si od toho pohodlnější implementaci algoritmů pro řešení kostky. Jednotlivé stěny jsou pak uloženy v rámci pole ve třídě Cube. Zde si také pamatuji jakým způsobem je kostka natočena k řešiteli (pozorovateli) a to tak, že si ukládám jaká je středová barva horní a čelní stěny.

Při psaní jsem však narazil na drobný problém. Původně jsem chtěl jednotlivé kostky uložit do jednoho pole. To by se dalo udělat přes společný interface. Jenže kostky nemají jednotný počet barev a proto by bylo složité vracet jejich hodnoty pomocí metod z jednoho předka. Interface jsem prozatím v kódu ponechal, možná se k jeho plné implementaci v budoucnu vratím. Nyní jsem však tuto myšlenku opustil a strana si ukládá kostky v rámci specializovaných polí. Zároveň trochu začínám pochybovat jestli zvolené řešení není zbytečně komplikované. Nic mi ale nebrání se v budoucnu uchýlit k jednodušší variantě. Například si v rámci stěn nadefinovat pouze pole barev, kde bych si pamatoval pouze barvy dané stěny.

Přesto, že ve výsledku půjde o WinForm aplikaci uchýlil jsem se zatím pouze ke konzolovému výstupu. Bylo jednodušší ho implementovat a lze s ním lehce otestovat funkčnost kódu. Jedinou nevýhodou je absence oranžové barvy v konzoli. Oranžová je tedy nahrazena magentou. 

Momentálně umí program uložit do paměti vyřešenou kostku a zpětně ji vypsat do konzole. V následujících dnech mě čeká implementace funkcí pro pohyb kostky. S jejich pomocí pak půjde s kostkou v paměti otáčet. Následovat bude postupná implementace jednotlivých algoritmů.

### 2. den
Dnes jsem se pustil do implementace pohybů kostky. Začal jsem těmi základními, tedy U, D, R, L, F, B a jejich inverzemi. Chvíli mi přišlo, že to bude lehce problematické, protože kostka se v době, kdy má k pohybu dojít, nemusí nacházet v počáteční pozici (tu jsem si definoval tak, že čelní stěna kostky je červená a horní žlutá). Záhy jsem ale přišel na to, že to až tak velký problém nebude. Postačí všechny pohyby naprogramovat pro tuto základní polohu a případné otáčení v jiných polohách nahradit korespondujícími pohyby v základní poloze.

Vrhnul jsem se tedy na implementaci. Během ní jsem se opět dostal k problému jak jednotlivé strany reprezentovat v paměti. Myslel jsem, že se mi moje obsáhlejší reprezentace bude hodit při implementaci. Ukázalo se však, že není vůbec potřeba. Rozhodl jsem se tedy reprezentaci zjednodušit. Jednotlivé stěny si tak ukládají pouze pole stejných políček, kde v každém je uložena pouze barva na dané stěně. Zatím ale nechci uplně vyhodit ani starou složitější reprezentaci. V kódu jsem ji tak zatím ponechal v rámci komentářů a pokud se v budoucnu ukáže, že by se mi hodila tak se k ní vrátím.

Po naimplementování všech základních pohybů jsem se zamyslel nad implementací těch složitějších. Došlo mi, že je možné je naimplementovat pomocí těch základních a rotace. Začal jsem tedy s implementací rotace. Po dokončení jsem si chtěl funkčnost otestovat. Narazil jsem však na menší problém. Došlo mi, že tak jak mám základní pohyby L, R, F a B naimplementované tak jsou dobré pouze pokud je kostka v počáteční pozici. Jinak totiž nesedí rozložení políček na bílé a žluté stěně. Při hledání řešení jsem si uvědomil další nedostatek mého kódu. Ukázalo se totiž, že pohyby F a B by bylo možné naimplementovat i pomocí L a R. A pokud by se to mělo vzít do detailu pohyb L, lze nahradit pohybem R (a obráceně samozřejmě). Bylo by potřeba pouze vhodně zadat parametry pro pohyb.

Zároveň jsem si uvědolmil, že ani moje jednoduchá funkce na vypsaní kostky není bez chyb. Dokáže totiž kostku vypsat pouze v základní pozici a to i když je v paměti uložena v jiné. V budoucnu ji tedy budu muset upravit tak, aby dokázala kostku vypsat v takové pozici jaká je právě uložena v paměti.

Dnes tedy končím s rozpracovanou implementací pohybu. Díky chybám v základních pohybech jsem se k pokročilým nedostal. Během dalších dnů doladím pohyb kosty. Nejspíš se pokusím pohyby co nejvíce ořezat. Počítám, že mi nakonec zbyde pouze implementace pohybů U, D, R a jejich inverzí.

### 3. den
Podle plánu z minula jsem se vrhnul na opravu a doimplementování pohybů. Začal jsem tím, že jsem všechny pohyby převedl tak, aby využívaly pouze implementaci pohybů yU, yD, yR a jejich inverzí. Během toho jsem narazil na pár chyb v mém dosavadním kódu. V rámci vypisování kostky jsem barvu stěny četl ze špatného políčka na stěně. V rámci implementace R (a inverzního R) jsem indexoval políčka na zadní straně obráceně (0, 3, 6 namísto 6, 3, 0). Chyba nebyla zřejmá protože pohyby testuji na složené kostce a zatím je moc nekombinuji. Indexaci jsem upravil a doplnil i funkce které na základě barvy přední strany kostky vrátí příslušné indexy na žluté a bílé stěně kostky tak, aby bylo možné provést R (a jeho inverzi). Následně jsem začal implementovat zbylé pohyby. Během jejich implementace jsem zjistil, že v rámci L a R pohybů (a jejich inverzí) nezohledňuji případ, kdy je žlutá či bílá barva na přední stěně. Případy jsem lehce ošetřil a pokračoval v implementaci. Po dokončení jsem se pustil do testování sekvencí pohybů. Hned jsem ale narazil na problém. Při implementaci pohybů yU, yD a yR (a jejich inverzí) totiž nerotuji s políčky na rotovaných stěnách (při pohybu U se políčka na horní stěně neotočí kolem středu). Doteď jsem si toho nevšiml kvůli tomu, že pohyby testuji na složené kostce (jak jsem již zmiňoval výše). Tuto chybu budu opravovat až příště. Společně s tím na mě čeká implementace lepšího vypsaní kostky, kterou jsem avizoval již minule.

### 4.den
Začal jsem opravou chyby z minula. Nebylo to nic náročného. Zároveň jsem během opravování udělal pár vylepšení v kódu. Funkce rotace yR dříve vyžadovala barvu přední a zadní stěny kostky. Ukázalo se však, že po opravení chyby by bylo zapotřebí vyžadovat i barvu pravé stěny. Kód byl tedy upraven tak, že funkce vyžaduje pouze barvu přední stěny. Zbylé barvy si dopočítá sama. Zároveň jsem přesunul funkce počítající souřadnice na žluté a bílé stěně (GetYCoordinates a GetWCoordinates) do samotné kostky a rozšířil je na celou stěnu. Toto sjednocené indexování mi jistě pomůže při psaní řešících algoritmů. Následně jsem otestoval jestli jsem se chyby zbavil. Bylo tomu skutečně tak, bohužel se ukázalo, že chyba se nachází i ve funkcích pro Y a Z rotaci. Náprava však nebyla složitá.

Provedl jsem také vyčištění kódu. Zbavil jsem se zakomentovaných sekcí, které používaly složitější variantu ukládání kostky v paměti. Zbavil jsem se i tříd, které tuto variantu uložení podporovaly. S rostoucí velikostí kódu by bylo složité se k této variantě vracet a přijde mi, že se obejdu i bez ní.

Následně jsem se pustil do psaní vylepšené verze vypisování. Nyní se kostka vypíše v rotaci v jaké je v paměti uložena.

Jako další jsem dnes naimplementoval funkci, která dokáže načíst do paměti kostku na základě hodnot od uživatele. Vzhledem k tomu, že se stejně bude aplikace přesouvat z konzole do jiného UI, tak je implementace velice primitivní. Nijak nekontroluje správnost vstupu a tak to i zůstane. Přijde mi zbytečné nad tím v tuto chvíli ztrácet čas. Ošetření nevhodných vstupů tak bude implementováno až s novým UI.

Plán na další dny je jasný, implementace algoritmů pro skládání kostky dle návodu pro začátečníky. Jako první mě čeká algoritmus na White Cross.
